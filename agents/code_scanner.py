import os
import ast
import logging
from pathlib import Path
from typing import List, Set, Dict

logger = logging.getLogger(__name__)

class CodeScannerAgent:
    """
    Scans Python files to extract imports and detect system requirements.
    Does NOT use LLM - uses static analysis (ast) for speed and zero cost.
    """

    def __init__(self, output_dir: str):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def scan_all_files(self, file_paths: List[Path], root_dir: Path, project_name: str = "project") -> Path:
        """
        Scans all provided files and generates a summary text file.
        
        Args:
            file_paths: List of files to scan
            root_dir: Root directory of the project
            project_name: Name of the project (used for filename)
            
        Returns:
            Path to the generated summary file
        """
        all_imports = set()
        detected_versions = {}
        cuda_required = False
        python_version_hint = None

        logger.info(f"Scanning {len(file_paths)} files...")

        for file_path in file_paths:
            try:
                # Only scan .py files for imports
                if file_path.suffix == '.py':
                    imports, has_cuda = self._scan_python_file(file_path)
                    all_imports.update(imports)
                    if has_cuda:
                        cuda_required = True
                
                # Check for version hints in requirements.txt or pyproject.toml
                # (Simple text check)
                if file_path.name == 'requirements.txt':
                    # TODO: Add simple requirements parsing logic here if needed
                    pass

            except Exception as e:
                logger.warning(f"Failed to scan {file_path}: {e}")

        # [변경점] 파일명에 프로젝트 이름을 넣습니다.
        # 예: dependency_summary_nanogpt.txt
        summary_filename = f"dependency_summary_{project_name}.txt"
        output_path = self.output_dir / summary_filename

        self._write_summary(output_path, all_imports, cuda_required, project_name)
        
        return output_path

    def _scan_python_file(self, file_path: Path):
        """Extract imports using AST."""
        imports = set()
        has_cuda = False
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                
            # Check for CUDA hints in text
            if "cuda" in content.lower() or "gpu" in content.lower() or "torch.device" in content:
                has_cuda = True

            tree = ast.parse(content)
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for name in node.names:
                        imports.add(name.name.split('.')[0])
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        imports.add(node.module.split('.')[0])
                        
        except Exception:
            # AST parsing might fail on some files, just ignore
            pass
            
        return imports, has_cuda

    def _write_summary(self, path: Path, imports: Set[str], cuda_required: bool, project_name: str):
        """Write the summary to a text file."""
        sorted_imports = sorted(list(imports))
        
        content = [
            f"# Dependency Summary for {project_name}",
            f"# Generated by EnvAgent CodeScanner",
            "",
            f"CUDA Required: {'Yes' if cuda_required else 'No'}",
            "",
            "Detected Imports:",
        ]
        
        # Filter out standard library (rough filter)
        import sys
        std_lib = set(sys.builtin_module_names)
        # Common std libs that AST picks up
        std_lib.update(['os', 'sys', 're', 'math', 'json', 'time', 'random', 'pathlib', 'typing', 'collections', 'logging'])
        
        for imp in sorted_imports:
            if imp not in std_lib and not imp.startswith('_'):
                content.append(f"- {imp}")
                
        with open(path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(content))
            
        logger.info(f"Summary saved to {path}")